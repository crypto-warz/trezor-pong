/* -------------------------------------------------------------------------- *
 * File: trezor-pong.c
 * Description: Pong on the Trezor One
 * Author: Anthony DeRosa
 * Date July 2018
 * Acknowledgements: Ported from https:// github.com/flightcrank/pong
 * -------------------------------------------------------------------------- */
#include <stdlib.h>
#include <stdio.h>

#include "buttons.h"
#include "usb.h"
#include "oled.h"
#if EMULATOR
#include "trezor-sdl.h"
#else
struct {
    int w;
    int h;
} screen = { OLED_WIDTH, OLED_HEIGHT };
#endif

#define WINNING_SCORE 3

typedef struct ball_s {
    int x, y;   // position on the screen
    int w,h;    // ball width and height
    int dx, dy; // movement vector
} ball_t;

typedef struct paddle {
    int x,y;
    int w,h;
} paddle_t;

// asset instances
static ball_t ball;
static paddle_t paddle[2];
static int score[] = {0,0};

static const uint8_t bmp_title_data[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xf8, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xf8, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xf8, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xf8, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xf8, 0x00, 0x78, 0x03, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xc0,
0x03, 0xf8, 0x00, 0x78, 0x07, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xc0,
0x03, 0xf8, 0x00, 0x78, 0x07, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xc0,
0x03, 0xff, 0xff, 0xf8, 0x07, 0xf8, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xe0, 0x03, 0xc0,
0x03, 0xff, 0xff, 0xf8, 0x07, 0xf8, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xe0, 0x03, 0xc0,
0x03, 0xff, 0xff, 0xf0, 0x07, 0xf8, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xe0, 0x03, 0xc0,
0x03, 0xff, 0xff, 0xe0, 0x07, 0xf8, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xe0, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xf8, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xe0, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xf8, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xe0, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xf8, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xe0, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xfc, 0x00, 0xf0, 0x0f, 0xf0, 0x01, 0xe0, 0x1f, 0xf0, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xfe, 0x00, 0xf0, 0x0f, 0xfc, 0x01, 0xe0, 0x1f, 0xf8, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x00, 0xf0, 0x0f, 0xfc, 0x01, 0xe0, 0x1f, 0xfc, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xfe, 0x03, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xff, 0xff, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x1f, 0xff, 0xff, 0xc0,
0x03, 0xff, 0x80, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x0f, 0xfe, 0x01, 0xe0, 0x0f, 0xff, 0xff, 0xc0,
0x01, 0xff, 0x00, 0x00, 0x01, 0xff, 0xff, 0xe0, 0x07, 0xfc, 0x01, 0xe0, 0x07, 0xff, 0xff, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xc0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t bmp_game_over_data[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
0x0e, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
0x0e, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
0x0e, 0x00, 0x3f, 0xc0, 0xff, 0xff, 0x0f, 0xf0, 0x00, 0x18, 0x3e, 0x38, 0x21, 0xff, 0x0f, 0xf0,
0x0e, 0x00, 0x3f, 0xe1, 0xff, 0xff, 0x9f, 0xf8, 0x00, 0x18, 0x3e, 0x7c, 0x23, 0xff, 0x1f, 0xf0,
0x0e, 0x1f, 0x30, 0x61, 0xc1, 0x81, 0x9c, 0x18, 0x00, 0x18, 0x1e, 0x7c, 0x23, 0x81, 0x1e, 0x00,
0x0f, 0x9f, 0xb0, 0x61, 0xc1, 0x81, 0x9c, 0x18, 0x00, 0x18, 0x0e, 0x7c, 0x23, 0x81, 0x1e, 0x00,
0x0f, 0x81, 0x80, 0x61, 0xc1, 0x81, 0x9c, 0x18, 0x00, 0x18, 0x0e, 0x7c, 0x23, 0x81, 0x1e, 0x00,
0x0f, 0x81, 0x80, 0x71, 0xe1, 0x81, 0x9c, 0x18, 0x00, 0x18, 0x0e, 0x7c, 0x23, 0x81, 0x1e, 0x00,
0x0f, 0x81, 0x9f, 0xf9, 0xf1, 0xe1, 0x9f, 0xf8, 0x00, 0x18, 0x0e, 0x7c, 0x23, 0xff, 0x1f, 0x00,
0x0f, 0x81, 0x9f, 0xf9, 0xf1, 0xf1, 0x9f, 0xf0, 0x00, 0x18, 0x0e, 0x3c, 0x63, 0xff, 0x1f, 0x00,
0x0f, 0x81, 0xbc, 0x79, 0xf1, 0xf1, 0x9f, 0x00, 0x00, 0x18, 0x0e, 0x1c, 0xe3, 0xe0, 0x1f, 0x00,
0x0f, 0x81, 0xbc, 0x79, 0xf1, 0xf1, 0x9f, 0x00, 0x00, 0x18, 0x0e, 0x1c, 0xe3, 0xe0, 0x1f, 0x00,
0x0f, 0x81, 0xbc, 0x79, 0xf1, 0xf1, 0x9f, 0x18, 0x00, 0x18, 0x0e, 0x1c, 0xc3, 0xe1, 0x1f, 0x00,
0x0f, 0x81, 0xbc, 0x79, 0xf1, 0xf1, 0x9f, 0x18, 0x00, 0x18, 0x0e, 0x1c, 0xc3, 0xe1, 0x1f, 0x00,
0x0f, 0xff, 0x1f, 0xf9, 0xf0, 0xe1, 0x9f, 0xf8, 0x00, 0x1f, 0xfe, 0x1f, 0x83, 0xff, 0x1f, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const BITMAP bmp_title = {128, 64, bmp_title_data};
static const BITMAP bmp_game_over = {128, 64, bmp_game_over_data};

#if EMULATOR
SDL_Surface screen = {
    .w = OLED_WIDTH,
    .h = OLED_HEIGHT
};
#endif

// initialize starting position and sizes of game elemements
static void
init_ball(void) {
    
    ball.x = screen.w / 2;
    ball.y = screen.h / 2;
    ball.w = 1;
    ball.h = 1;
    ball.dy = 1;
    ball.dx = 1;
    
    paddle[0].x = 2;
    paddle[0].y = screen.h / 2 - 5;
    paddle[0].w = 1;
    paddle[0].h = 15;

    paddle[1].x = screen.w - 2 - 1;
    paddle[1].y = screen.h / 2 - 5;
    paddle[1].w = 1;
    paddle[1].h = 15;
}

static int
check_score(void) {
    
    int i;

    // loop through player scores
    for(i = 0; i < 2; i++) {
    
        // check if score is @ the score win limit
        if (score[i] == WINNING_SCORE ) {
        
            // reset scores
            score[0] = 0;
            score[1] = 0;
            
            // return 1 if player 1 score @ limit
            if (i == 0) {

                return 1;   

            // return 2 if player 2 score is @ limit
            } else {
                
                return 2;
            }
        }
    }
    
    // return 0 if no one has reached a score of WINNING_SCORE yet
    return 0;
}

// if return value is 1 collision occured. if return is 0, no collision.
static int
check_collision(ball_t a, paddle_t b) {

    int left_a, left_b;
    int right_a, right_b;
    int top_a, top_b;
    int bottom_a, bottom_b;

    left_a = a.x;
    right_a = a.x + a.w;
    top_a = a.y;
    bottom_a = a.y + a.h;

    left_b = b.x;
    right_b = b.x + b.w;
    top_b = b.y;
    bottom_b = b.y + b.h;
    

    if (left_a > right_b) {
        return 0;
    }

    if (right_a < left_b) {
        return 0;
    }

    if (top_a > bottom_b) {
        return 0;
    }

    if (bottom_a < top_b) {
        return 0;
    }

    return 1;
}

/* This routine moves each ball by its motion vector. */
static void
move_ball(void) {
    
    /* Move the ball by its motion vector. */
    ball.x += ball.dx;
    ball.y += ball.dy;
    
    /* Turn the ball around if it hits the edge of the screen. */
    if (ball.x < 0) {
        
        score[1] += 1;
        init_ball();
    }

    if (ball.x > screen.w - 1) { 
        
        score[0] += 1;
        init_ball();
    }

    if (ball.y < 0 || ball.y > screen.h - 1) {
        
        ball.dy = -ball.dy;
    }

    // check for collision with the paddle
    int i;

    for (i = 0; i < 2; i++) {
        
        int c = check_collision(ball, paddle[i]); 

        // collision detected    
        if (c == 1) {
            
            // ball moving left
            if (ball.dx < 0) {
                    
                ball.dx -= 1;

            // ball moving right
            } else {
                    
                ball.dx += 1;
            }
            
            // change ball direction
            ball.dx = -ball.dx;
            
            // change ball angle based on where on the paddle it hit
            int hit_pos = (paddle[i].y + paddle[i].h) - ball.y;

            if (hit_pos >= 0 && hit_pos < 1) {
                ball.dy = 4;
            }

            if (hit_pos >= 1 && hit_pos < 2) {
                ball.dy = 3;
            }
            
            if (hit_pos >= 2 && hit_pos < 4) {
                ball.dy = 2;
            }

            if (hit_pos >= 4 && hit_pos < 6) {
                ball.dy = 1;
            }

            if (hit_pos >= 6 && hit_pos < 9) {
                ball.dy = 0;
            }

            if (hit_pos >= 9 && hit_pos < 11) {
                ball.dy = -1;
            }

            if (hit_pos >= 11 && hit_pos < 13) {
                ball.dy = -2;
            }

            if (hit_pos >= 13 && hit_pos < 14) {
                ball.dy = -3;
            }

            if (hit_pos >= 14 && hit_pos <= 15) {
                ball.dy = -4;
            }

            // ball moving right
            if (ball.dx > 0) {

                // teleport ball to avoid mutli collision glitch
                if (ball.x < 1) {
                
                    ball.x = 1;
                }
                
            // ball moving left
            } else {
                
                // teleport ball to avoid mutli collision glitch
                if (ball.x > 127) {
                
                    ball.x = 127;
                }
            }
        }
    }
}

static void
move_paddle_ai(void) {

    int center = paddle[0].y;
    int screen_center = screen.h / 2;
    int ball_speed = ball.dy;

    if (ball_speed < 0) {
    
        ball_speed = -ball_speed;
    }

    // ball moving right
    if (ball.dx > 0) {
        
        // return to center position
        if (center < screen_center) {
            
            paddle[0].y += ball_speed;
        
        } else {
        
            paddle[0].y -= ball_speed;  
        }

    // ball moving left
    } else {
    
        // ball moving down
        if (ball.dy > 0) { 
            
            if (ball.y > center) { 
                
                paddle[0].y += ball_speed;

            } else { 
            
                paddle[0].y -= ball_speed;
            }
        }
        
        // ball moving up
        if (ball.dy < 0) {
        
            if (ball.y < center) { 
                
                paddle[0].y -= ball_speed;
            
            } else {
            
                paddle[0].y += ball_speed;
            }
        }

        // ball moving stright across
        if (ball.dy == 0) {
            
            if (ball.y < center) { 
            
                paddle[0].y -= 5;

            } else {
            
                paddle[0].y += 5;
            }
        }           
    }
}

static void
move_paddle(int d) {

    // if the down arrow is pressed move paddle down
    if (d == 0) {
        
        if(paddle[1].y >= screen.h - paddle[1].h) {
        
            paddle[1].y = screen.h - paddle[1].h;
        
        } else { 
        
            paddle[1].y += 5;
        }
    }
    
    // if the up arrow is pressed move paddle up
    if (d == 1) {

        if(paddle[1].y <= 0) {
        
            paddle[1].y = 0;

        } else {
        
            paddle[1].y -= 5;
        }
    }
}

static void
draw_game_over(int p) { 

    char *winner;
    if (p == 2)
    {
        winner = "Player 1 wins!";
    }
    else
    {
        winner = "Computer wins!";
    }

    oledDrawBitmap(0, 0, &bmp_game_over);
    oledDrawStringCenter(OLED_WIDTH / 2, 8, winner, FONT_STANDARD);
    oledDrawStringCenter(OLED_WIDTH / 2, OLED_HEIGHT - 8, "Press any button to begin!", FONT_STANDARD);
    return;
}

static void
draw_menu(void) {

    oledDrawBitmap(0, 0, &bmp_title);
    oledDrawStringCenter(OLED_WIDTH / 2, OLED_HEIGHT - 8, "Press any button to begin!", FONT_STANDARD);
    return;
}

static void
draw_background(void) {
#if EMULATOR
    SDL_Rect src;
    
    // draw bg with net
    src.x = 0;
    src.y = 0;
    src.w = screen.w;
    src.h = screen.h;

    // draw the backgorund
    int r = SDL_FillRect(&screen,&src,0);
    
    if (r !=0){
        
        printf("fill rectangle faliled in func draw_background()");
    }
#else
    oledClear();
#endif
}

static void
draw_net(void) {
#if EMULATOR
    SDL_Rect net;
    
    net.x = screen.w / 2;
    net.y = 2;
    net.w = 1;
    net.h = 5;

    // draw the net
    int i,r;

    for(i = 0; i < 12; i++) {
        
        r = SDL_FillRect(&screen,&net,255);
    
        if (r != 0) { 
        
            printf("fill rectangle faliled in func draw_background()");
        }

        net.y = net.y + 5;
    }
#else
    int x = OLED_WIDTH / 2;
    int y = 2;
    for (int i = 0; i < 12; i++) {
        for (int dy = 0; dy < 5; dy++) {
            oledDrawPixel(x, y + dy);
        }
        y += 5;
    }
#endif
}

static void
draw_ball(void) {
#if EMULATOR
    SDL_Rect src;

    src.x = ball.x;
    src.y = ball.y;
    src.w = ball.w;
    src.h = ball.h;

    int r = SDL_FillRect(&screen,&src,255);

    if (r !=0){
    
        printf("fill rectangle faliled in func drawball()");
    }
#else
    for (int dx = 0; dx < ball.w; dx++) {
        for (int dy = 0; dy < ball.h; dy++) {
            oledDrawPixel(ball.x + dx, ball.y + dy);
        }
    }
#endif
}

void
draw_paddle(void) {
#if EMULATOR
    SDL_Rect src;
    int i;

    for (i = 0; i < 2; i++) {
    
        src.x = paddle[i].x;
        src.y = paddle[i].y;
        src.w = paddle[i].w;
        src.h = paddle[i].h;
        
        int r = SDL_FillRect(&screen,&src,255);
        
        if (r !=0){
        
            printf("fill rectangle faliled in func draw_paddle()");
        }
    }
#else
    for (int i = 0; i < 2; i++) {
        for (int dx = 0; dx < paddle[i].w; dx++) {
            for (int dy = 0; dy < paddle[i].h; dy++) {
                oledDrawPixel(paddle[i].x + dx, paddle[i].y + dy);
            }
        }
    }
#endif
}

static void
draw_player_0_score(void) {
    char scoreStr[2] = {0};
    scoreStr[0] = (char)(score[0] + 0x30);
    scoreStr[1] = '\0';
    oledDrawString(screen.w/2 - 20 - fontCharWidth(FONT_STANDARD, scoreStr[0]), 0, scoreStr, FONT_STANDARD);
}

static void
draw_player_1_score(void) {
    char scoreStr[2] = {0};
    scoreStr[0] = (char)(score[1] + 0x30);
    scoreStr[1] = '\0';
    oledDrawString(screen.w/2 + 20, 0, scoreStr, FONT_STANDARD);
}

int
pong_main(void) {

    /* Initialize the ball position data. */
    init_ball();

    int state = 0;
    int r = 0;
    int quit = 0;
    int sleep = 0;

#if EMULATOR
    Uint32 next_game_tick = SDL_GetTicks();
#else
    uint32_t next_game_tick = timer_ms();  // аналог SDL_GetTicks()
#endif

    /* Animate */
    while (quit == 0) {
        sleep = 50;
        
        buttonUpdate();
        if (button.NoUp)
        {
            move_paddle(0);
        }
        else if(button.YesUp)
        {
            move_paddle(1);
        }
        
        // draw the background
        draw_background();
        draw_net();

        // display main menu
        if (state == 0 ) {
        
            if (button.NoUp || button.YesUp)
            {
                state = 1;
            }
        
            // draw menu 
            draw_menu();
        
        // display gameover
        } else if (state == 2) {
        
#if EMULATOR
            if (button.NoDown && button.YesDown)
            {
                state = 0;
                // delay for a little bit so the space bar press dosnt get triggered twice
                // while the main menu is showing
                SDL_Delay(500);
            }
#else
            if (button.NoDown && button.YesDown) {
                state = 0;
                delay(500);
            }
#endif

            // display gameover
            draw_game_over(r);

            if (button.NoUp || button.YesUp)
            {
                state = 1;
            }
                
        // display the game
        } else if (state == 1){
            
            // check score
            r = check_score();
            
            if (r == 1) {
                
                state = 2;  

            } else if (r == 2){
            
                state = 2;  
            }

            // paddle ai movement
            move_paddle_ai();

            /* Move the balls for the next frame. */
            move_ball();
            
            // draw net
            draw_net();

            // draw paddles
            draw_paddle();
            
            /* Put the ball on the screen. */
            draw_ball();
    
            // draw the score
            draw_player_0_score();
    
            // draw the score
            draw_player_1_score();
        }

#if EMULATOR
        /* Ask SDL to update the entire screen. */
        SDL_Flip(&screen);

        next_game_tick += 1000 / 10;
        sleep = next_game_tick - SDL_GetTicks();
    
        if( sleep >= 0 )
        {
            SDL_Delay(sleep);
        }
#else
        oledRefresh();
        next_game_tick += 1000 / 10;
        sleep = next_game_tick - timer_ms();

        if (sleep >= 0) {
            delay(sleep);
        }
#endif

    }
    
    return 0;
}
